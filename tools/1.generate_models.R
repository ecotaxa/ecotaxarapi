#
# Parse openapi.json to define data models
#
# (c) 2025 J-O Irisson, T Pana√Øotis GNU General Public License v3

library("tidyverse")
library("glue")
library("styler")

source("tools/0.read_openapi_and_prepare.R")

## Define functions ----

#' Detect the schema's nature: Enum or Model
#'
#' @param x an element of api$components$schemas
schema_type <- function(x) {
  if (!is.null(x$enum)) {
    type <- "enum"
  } else {
    type <- "model"
  }
  return(type)
}

#' Extract the type of a property in a Model
#'
#' @param x property of a schema
prop_type <- function(x) {
  # deal with empty types (e.g. list())
  if (length(x) == 0) {
    type <- NULL
  } else {
    if (is.null(x$type)) {
      # specific type of object, defined as a Model
      if (!is.null(x$`$ref`)) {
        model <- x$`$ref` %>% str_split("/") %>% pluck(1) %>% tail(1)
        type <- str_c("object of type [", model, "]")
      }
      # multiple types
      if (!is.null(x$allOf)) {
        type <- sapply(x$allOf, prop_type) |>
          # reduce this to a single string
          unlist() |> str_c(collapse=", ")
      }
      if (!is.null(x$anyOf)) {
        type <- sapply(x$anyOf, prop_type) |>
          unlist() |> str_c(collapse=", ")
      }
    } else {
      if (x$type == "array") {
        # vector of stuff
        type <- x$items$type
        type <- str_c("vector of ", type)
      } else if (x$type == "object") {
        # generic object, not a given type/Model
        type <- "list"
      } else (
        # or just get the actual type
        type <- x$type
      )
    }
  }
  return(type)
}

#' Parse a Model's properties
#'
#' @param x an element of api$components$schemas
model_props <- function(x) {
  # name of required properties
  required_props <- unlist(x$required)

  # parse all properties
  props <- imap(x$properties, function(prop, name) {
    # add a common set of characteristics for each property
    prop$name <- name
    prop$required <- name %in% required_props
    prop$type <- prop_type(prop)
    if (is.null(prop$title)) {prop$title <- name}
    if (is.null(prop$description)) {prop$description <- prop$title}
    prop$description <- str_replace_all(prop$description, "\n", " ")
    return(prop)
  })
  return(props)
}


## Actually parse the file and write functions ----

schemas <- api$components$schemas

iwalk(schemas, function(sch, sch_name) {
  message("  write doc. for ", sch_name)

  sch_type <- schema_type(sch)

  if (sch_type == "enum") {
    # Format an enum (i.e. list of possibilities)

    # the documentation part, that describes the enum
    doc <- c(
      sch$title,
      "",
      str_c("A vector defining a ", sch$title),
      "",
      str_c("@format ", sch$type, " containing ", glue_collapse(sch$enum, ", ", last=" or ")),
      "",
      str_c("@name ", sch_name),
      "@export"
    )
    # the "function" part, which is just a placeholder
    fun <- "NULL"

  }  else {
    # Format a Model

    # get its list of properties, correctly/homogeneously structured
    props <- model_props(sch)

    # documentation part
    doc <- c(
      sch$title,
      "",
      str_c("A list defining a ", sch$title),
      "",
      map_chr(props, glue_data, "@param {name} \\[{type}{ifelse(required, ', required', '')}\\] {description}"),
      "",
      "@export"
    )
    # TODO add example

    # the function itself, that defines the object
    fun <- c(
      str_c(sch_name, " <- function(",
            str_c(gel(props, "name"), ifelse(gel(props, "required"), "", "=NULL"), collapse=", "),
            ") {"),
      "  body <- list(",
      str_c(map_chr(props, glue_data, "    {name}={name}"), collapse = ",\n"),
      "  )",
      "  body[sapply(body, is.null)] <- NULL",
      "  return(body)",
      "}"
    )
  }

  out <- c(
    "# Automatically generated. Do not edit this file.",
    str_c("#' ", doc),
    fun
  )
  cat(out, file=str_c("R/", sch_name, ".R"), sep="\n")
})
